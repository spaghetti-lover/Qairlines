// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tickets.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelTicket = `-- name: CancelTicket :one
UPDATE Tickets
SET status = 'Cancelled',
    updated_at = NOW()
WHERE Tickets.ticket_id = $1
    AND status = 'Active'
RETURNING ticket_id,
    status,
    flight_class,
    price,
    booking_id,
    flight_id,
    updated_at,
    (
        SELECT seat_code
        FROM Seats
        WHERE seat_id = Tickets.seat_id
    ) AS seat_code,
    (
        SELECT first_name
        FROM TicketOwnerSnapshots
        WHERE ticket_id = Tickets.ticket_id
    ) AS owner_first_name,
    (
        SELECT last_name
        FROM TicketOwnerSnapshots
        WHERE ticket_id = Tickets.ticket_id
    ) AS owner_last_name,
    (
        SELECT phone_number
        FROM TicketOwnerSnapshots
        WHERE ticket_id = Tickets.ticket_id
    ) AS owner_phone_number
`

type CancelTicketRow struct {
	TicketID         int64        `json:"ticket_id"`
	Status           TicketStatus `json:"status"`
	FlightClass      FlightClass  `json:"flight_class"`
	Price            int32        `json:"price"`
	BookingID        pgtype.Int8  `json:"booking_id"`
	FlightID         int64        `json:"flight_id"`
	UpdatedAt        time.Time    `json:"updated_at"`
	SeatCode         string       `json:"seat_code"`
	OwnerFirstName   pgtype.Text  `json:"owner_first_name"`
	OwnerLastName    pgtype.Text  `json:"owner_last_name"`
	OwnerPhoneNumber pgtype.Text  `json:"owner_phone_number"`
}

func (q *Queries) CancelTicket(ctx context.Context, ticketID int64) (CancelTicketRow, error) {
	row := q.db.QueryRow(ctx, cancelTicket, ticketID)
	var i CancelTicketRow
	err := row.Scan(
		&i.TicketID,
		&i.Status,
		&i.FlightClass,
		&i.Price,
		&i.BookingID,
		&i.FlightID,
		&i.UpdatedAt,
		&i.SeatCode,
		&i.OwnerFirstName,
		&i.OwnerLastName,
		&i.OwnerPhoneNumber,
	)
	return i, err
}

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (
        seat_id,
        flight_class,
        price,
        status,
        booking_id,
        flight_id
    )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING ticket_id, seat_id, flight_class, price, status, booking_id, flight_id, created_at, updated_at
`

type CreateTicketParams struct {
	SeatID      int64        `json:"seat_id"`
	FlightClass FlightClass  `json:"flight_class"`
	Price       int32        `json:"price"`
	Status      TicketStatus `json:"status"`
	BookingID   pgtype.Int8  `json:"booking_id"`
	FlightID    int64        `json:"flight_id"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, createTicket,
		arg.SeatID,
		arg.FlightClass,
		arg.Price,
		arg.Status,
		arg.BookingID,
		arg.FlightID,
	)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.SeatID,
		&i.FlightClass,
		&i.Price,
		&i.Status,
		&i.BookingID,
		&i.FlightID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE FROM tickets
WHERE ticket_id = $1
`

func (q *Queries) DeleteTicket(ctx context.Context, ticketID int64) error {
	_, err := q.db.Exec(ctx, deleteTicket, ticketID)
	return err
}

const getTicketByFlightId = `-- name: GetTicketByFlightId :many
SELECT ticket_id, seat_id, flight_class, price, status, booking_id, flight_id, created_at, updated_at
FROM tickets
WHERE flight_id = $1
ORDER BY ticket_id
`

func (q *Queries) GetTicketByFlightId(ctx context.Context, flightID int64) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, getTicketByFlightId, flightID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.TicketID,
			&i.SeatID,
			&i.FlightClass,
			&i.Price,
			&i.Status,
			&i.BookingID,
			&i.FlightID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketByID = `-- name: GetTicketByID :one
SELECT t.ticket_id,
    t.status,
    t.flight_class,
    t.price,
    t.booking_id,
    t.flight_id,
    t.created_at,
    t.updated_at,
    s.seat_code,
    s.seat_id,
    s.is_available,
    s.flight_id,
    s.class AS seat_class,
    o.first_name AS owner_first_name,
    o.last_name AS owner_last_name,
    o.gender AS owner_gender,
    o.phone_number AS owner_phone_number,
    o.date_of_birth AS owner_date_of_birth,
    o.passport_number AS owner_passport_number,
    o.identification_number AS owner_identification_number,
    o.address AS owner_address
FROM Tickets t
    LEFT JOIN Seats s ON t.seat_id = s.seat_id
    LEFT JOIN TicketOwnerSnapshots o ON t.ticket_id = o.ticket_id
WHERE t.ticket_id = $1
`

type GetTicketByIDRow struct {
	TicketID                  int64           `json:"ticket_id"`
	Status                    TicketStatus    `json:"status"`
	FlightClass               FlightClass     `json:"flight_class"`
	Price                     int32           `json:"price"`
	BookingID                 pgtype.Int8     `json:"booking_id"`
	FlightID                  int64           `json:"flight_id"`
	CreatedAt                 time.Time       `json:"created_at"`
	UpdatedAt                 time.Time       `json:"updated_at"`
	SeatCode                  pgtype.Text     `json:"seat_code"`
	SeatID                    pgtype.Int8     `json:"seat_id"`
	IsAvailable               pgtype.Bool     `json:"is_available"`
	FlightID_2                pgtype.Int8     `json:"flight_id_2"`
	SeatClass                 NullFlightClass `json:"seat_class"`
	OwnerFirstName            pgtype.Text     `json:"owner_first_name"`
	OwnerLastName             pgtype.Text     `json:"owner_last_name"`
	OwnerGender               NullGenderType  `json:"owner_gender"`
	OwnerPhoneNumber          pgtype.Text     `json:"owner_phone_number"`
	OwnerDateOfBirth          time.Time       `json:"owner_date_of_birth"`
	OwnerPassportNumber       pgtype.Text     `json:"owner_passport_number"`
	OwnerIdentificationNumber pgtype.Text     `json:"owner_identification_number"`
	OwnerAddress              pgtype.Text     `json:"owner_address"`
}

func (q *Queries) GetTicketByID(ctx context.Context, ticketID int64) (GetTicketByIDRow, error) {
	row := q.db.QueryRow(ctx, getTicketByID, ticketID)
	var i GetTicketByIDRow
	err := row.Scan(
		&i.TicketID,
		&i.Status,
		&i.FlightClass,
		&i.Price,
		&i.BookingID,
		&i.FlightID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SeatCode,
		&i.SeatID,
		&i.IsAvailable,
		&i.FlightID_2,
		&i.SeatClass,
		&i.OwnerFirstName,
		&i.OwnerLastName,
		&i.OwnerGender,
		&i.OwnerPhoneNumber,
		&i.OwnerDateOfBirth,
		&i.OwnerPassportNumber,
		&i.OwnerIdentificationNumber,
		&i.OwnerAddress,
	)
	return i, err
}

const getTicketsByBookingIDAndType = `-- name: GetTicketsByBookingIDAndType :many
SELECT ticket_id,
    seat_id,
    flight_class,
    price,
    status,
    booking_id,
    flight_id,
    created_at,
    updated_at
FROM Tickets
WHERE Tickets.booking_id = $1
    AND (
        (
            $2 = 'departure'
            AND flight_id = (
                SELECT departure_flight_id
                FROM Bookings
                WHERE Bookings.booking_id = $1
            )
        )
        OR (
            $2 = 'return'
            AND flight_id = (
                SELECT return_flight_id
                FROM Bookings
                WHERE Bookings.booking_id = $1
            )
        )
    )
`

type GetTicketsByBookingIDAndTypeParams struct {
	BookingID pgtype.Int8 `json:"booking_id"`
	Column2   interface{} `json:"column_2"`
}

func (q *Queries) GetTicketsByBookingIDAndType(ctx context.Context, arg GetTicketsByBookingIDAndTypeParams) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, getTicketsByBookingIDAndType, arg.BookingID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.TicketID,
			&i.SeatID,
			&i.FlightClass,
			&i.Price,
			&i.Status,
			&i.BookingID,
			&i.FlightID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketsByFlightID = `-- name: GetTicketsByFlightID :many
SELECT t.ticket_id,
    t.seat_id,
    t.flight_class,
    t.price,
    t.status,
    t.booking_id,
    t.flight_id,
    t.created_at,
    t.updated_at,
    s.seat_code,
    s.is_available,
    s.class AS seat_class,
    o.first_name AS owner_first_name,
    o.last_name AS owner_last_name,
    o.phone_number AS owner_phone_number,
    o.gender AS owner_gender,
    o.date_of_birth AS owner_date_of_birth,
    o.passport_number AS owner_passport_number,
    o.identification_number AS owner_identification_number,
    o.address AS owner_address
FROM Tickets t
    LEFT JOIN Seats s ON t.seat_id = s.seat_id
    LEFT JOIN TicketOwnerSnapshots o ON t.ticket_id = o.ticket_id
WHERE t.flight_id = $1
`

type GetTicketsByFlightIDRow struct {
	TicketID                  int64           `json:"ticket_id"`
	SeatID                    int64           `json:"seat_id"`
	FlightClass               FlightClass     `json:"flight_class"`
	Price                     int32           `json:"price"`
	Status                    TicketStatus    `json:"status"`
	BookingID                 pgtype.Int8     `json:"booking_id"`
	FlightID                  int64           `json:"flight_id"`
	CreatedAt                 time.Time       `json:"created_at"`
	UpdatedAt                 time.Time       `json:"updated_at"`
	SeatCode                  pgtype.Text     `json:"seat_code"`
	IsAvailable               pgtype.Bool     `json:"is_available"`
	SeatClass                 NullFlightClass `json:"seat_class"`
	OwnerFirstName            pgtype.Text     `json:"owner_first_name"`
	OwnerLastName             pgtype.Text     `json:"owner_last_name"`
	OwnerPhoneNumber          pgtype.Text     `json:"owner_phone_number"`
	OwnerGender               NullGenderType  `json:"owner_gender"`
	OwnerDateOfBirth          time.Time       `json:"owner_date_of_birth"`
	OwnerPassportNumber       pgtype.Text     `json:"owner_passport_number"`
	OwnerIdentificationNumber pgtype.Text     `json:"owner_identification_number"`
	OwnerAddress              pgtype.Text     `json:"owner_address"`
}

func (q *Queries) GetTicketsByFlightID(ctx context.Context, flightID int64) ([]GetTicketsByFlightIDRow, error) {
	rows, err := q.db.Query(ctx, getTicketsByFlightID, flightID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTicketsByFlightIDRow{}
	for rows.Next() {
		var i GetTicketsByFlightIDRow
		if err := rows.Scan(
			&i.TicketID,
			&i.SeatID,
			&i.FlightClass,
			&i.Price,
			&i.Status,
			&i.BookingID,
			&i.FlightID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeatCode,
			&i.IsAvailable,
			&i.SeatClass,
			&i.OwnerFirstName,
			&i.OwnerLastName,
			&i.OwnerPhoneNumber,
			&i.OwnerGender,
			&i.OwnerDateOfBirth,
			&i.OwnerPassportNumber,
			&i.OwnerIdentificationNumber,
			&i.OwnerAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTickets = `-- name: ListTickets :many
SELECT ticket_id, seat_id, flight_class, price, status, booking_id, flight_id, created_at, updated_at
FROM tickets
ORDER BY ticket_id
LIMIT $1 OFFSET $2
`

type ListTicketsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTickets(ctx context.Context, arg ListTicketsParams) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, listTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.TicketID,
			&i.SeatID,
			&i.FlightClass,
			&i.Price,
			&i.Status,
			&i.BookingID,
			&i.FlightID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSeat = `-- name: UpdateSeat :one
UPDATE Seats
SET seat_code = $2
WHERE seat_id = (
        SELECT seat_id
        FROM Tickets
        WHERE ticket_id = $1
            AND seat_id IS NOT NULL
    )
RETURNING seat_id, flight_id, seat_code, is_available, class
`

type UpdateSeatParams struct {
	TicketID int64  `json:"ticket_id"`
	SeatCode string `json:"seat_code"`
}

func (q *Queries) UpdateSeat(ctx context.Context, arg UpdateSeatParams) (Seat, error) {
	row := q.db.QueryRow(ctx, updateSeat, arg.TicketID, arg.SeatCode)
	var i Seat
	err := row.Scan(
		&i.SeatID,
		&i.FlightID,
		&i.SeatCode,
		&i.IsAvailable,
		&i.Class,
	)
	return i, err
}

const updateTicket = `-- name: UpdateTicket :exec
UPDATE tickets
SET flight_class = $2,
    price = $3,
    status = $4,
    booking_id = $5,
    flight_id = $6,
    updated_at = NOW()
WHERE ticket_id = $1
`

type UpdateTicketParams struct {
	TicketID    int64        `json:"ticket_id"`
	FlightClass FlightClass  `json:"flight_class"`
	Price       int32        `json:"price"`
	Status      TicketStatus `json:"status"`
	BookingID   pgtype.Int8  `json:"booking_id"`
	FlightID    int64        `json:"flight_id"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) error {
	_, err := q.db.Exec(ctx, updateTicket,
		arg.TicketID,
		arg.FlightClass,
		arg.Price,
		arg.Status,
		arg.BookingID,
		arg.FlightID,
	)
	return err
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE Tickets
SET status = $2,
    updated_at = NOW()
WHERE ticket_id = $1
RETURNING ticket_id, seat_id, flight_class, price, status, booking_id, flight_id, created_at, updated_at
`

type UpdateTicketStatusParams struct {
	TicketID int64        `json:"ticket_id"`
	Status   TicketStatus `json:"status"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, updateTicketStatus, arg.TicketID, arg.Status)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.SeatID,
		&i.FlightClass,
		&i.Price,
		&i.Status,
		&i.BookingID,
		&i.FlightID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
