// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: seats.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkSeatAvailability = `-- name: CheckSeatAvailability :one
SELECT is_available FROM "seats"
WHERE seat_code = $1 and flight_id = $2
`

type CheckSeatAvailabilityParams struct {
	SeatCode string      `json:"seat_code"`
	FlightID pgtype.Int8 `json:"flight_id"`
}

func (q *Queries) CheckSeatAvailability(ctx context.Context, arg CheckSeatAvailabilityParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkSeatAvailability, arg.SeatCode, arg.FlightID)
	var is_available bool
	err := row.Scan(&is_available)
	return is_available, err
}

const countOccupiedSeats = `-- name: CountOccupiedSeats :one
SELECT COUNT(*) FROM "seats"
WHERE flight_id = $1 AND is_available = false
`

func (q *Queries) CountOccupiedSeats(ctx context.Context, flightID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countOccupiedSeats, flightID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSeat = `-- name: CreateSeat :one
INSERT INTO "seats" (
  flight_id,
  seat_code,
  is_available,
  class
) VALUES (
  $1, $2, $3, $4
) RETURNING seat_id, flight_id, seat_code, is_available, class
`

type CreateSeatParams struct {
	FlightID    pgtype.Int8 `json:"flight_id"`
	SeatCode    string      `json:"seat_code"`
	IsAvailable bool        `json:"is_available"`
	Class       FlightClass `json:"class"`
}

func (q *Queries) CreateSeat(ctx context.Context, arg CreateSeatParams) (Seat, error) {
	row := q.db.QueryRow(ctx, createSeat,
		arg.FlightID,
		arg.SeatCode,
		arg.IsAvailable,
		arg.Class,
	)
	var i Seat
	err := row.Scan(
		&i.SeatID,
		&i.FlightID,
		&i.SeatCode,
		&i.IsAvailable,
		&i.Class,
	)
	return i, err
}

const getAllSeats = `-- name: GetAllSeats :many
SELECT seat_id, flight_id, seat_code, is_available, class FROM "seats"
`

func (q *Queries) GetAllSeats(ctx context.Context) ([]Seat, error) {
	rows, err := q.db.Query(ctx, getAllSeats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seat{}
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.SeatID,
			&i.FlightID,
			&i.SeatCode,
			&i.IsAvailable,
			&i.Class,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeat = `-- name: GetSeat :one
SELECT seat_id, flight_id, seat_code, is_available, class FROM "seats"
WHERE seat_id = $1 LIMIT 1
`

func (q *Queries) GetSeat(ctx context.Context, seatID int64) (Seat, error) {
	row := q.db.QueryRow(ctx, getSeat, seatID)
	var i Seat
	err := row.Scan(
		&i.SeatID,
		&i.FlightID,
		&i.SeatCode,
		&i.IsAvailable,
		&i.Class,
	)
	return i, err
}

const getSeatByTicketID = `-- name: GetSeatByTicketID :one
SELECT s.seat_id, s.seat_code, s.class, s.is_available
FROM Seats s
JOIN Tickets t ON s.seat_id = t.seat_id
WHERE t.ticket_id = $1
`

type GetSeatByTicketIDRow struct {
	SeatID      int64       `json:"seat_id"`
	SeatCode    string      `json:"seat_code"`
	Class       FlightClass `json:"class"`
	IsAvailable bool        `json:"is_available"`
}

func (q *Queries) GetSeatByTicketID(ctx context.Context, ticketID int64) (GetSeatByTicketIDRow, error) {
	row := q.db.QueryRow(ctx, getSeatByTicketID, ticketID)
	var i GetSeatByTicketIDRow
	err := row.Scan(
		&i.SeatID,
		&i.SeatCode,
		&i.Class,
		&i.IsAvailable,
	)
	return i, err
}

const listSeatsWithFlightId = `-- name: ListSeatsWithFlightId :many
SELECT seat_id, flight_id, seat_code, is_available, class FROM "seats"
WHERE flight_id = $1
`

func (q *Queries) ListSeatsWithFlightId(ctx context.Context, flightID pgtype.Int8) ([]Seat, error) {
	rows, err := q.db.Query(ctx, listSeatsWithFlightId, flightID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seat{}
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.SeatID,
			&i.FlightID,
			&i.SeatCode,
			&i.IsAvailable,
			&i.Class,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSeatUnavailable = `-- name: MarkSeatUnavailable :exec
UPDATE "seats"
SET is_available = false
WHERE seat_code = $1 AND flight_id = $2
`

type MarkSeatUnavailableParams struct {
	SeatCode string      `json:"seat_code"`
	FlightID pgtype.Int8 `json:"flight_id"`
}

func (q *Queries) MarkSeatUnavailable(ctx context.Context, arg MarkSeatUnavailableParams) error {
	_, err := q.db.Exec(ctx, markSeatUnavailable, arg.SeatCode, arg.FlightID)
	return err
}

const updateSeat = `-- name: UpdateSeat :exec
UPDATE "seats"
SET seat_code = $2,
    is_available = $3,
    class = $4,
    updated_at = NOW()
WHERE seat_id = $1
`

type UpdateSeatParams struct {
	SeatID      int64       `json:"seat_id"`
	SeatCode    string      `json:"seat_code"`
	IsAvailable bool        `json:"is_available"`
	Class       FlightClass `json:"class"`
}

func (q *Queries) UpdateSeat(ctx context.Context, arg UpdateSeatParams) error {
	_, err := q.db.Exec(ctx, updateSeat,
		arg.SeatID,
		arg.SeatCode,
		arg.IsAvailable,
		arg.Class,
	)
	return err
}

const updateSeatAvailability = `-- name: UpdateSeatAvailability :exec
UPDATE Seats
SET is_available = $2
WHERE seat_id = (SELECT seat_id FROM Tickets WHERE ticket_id = $1)
`

type UpdateSeatAvailabilityParams struct {
	TicketID    int64 `json:"ticket_id"`
	IsAvailable bool  `json:"is_available"`
}

func (q *Queries) UpdateSeatAvailability(ctx context.Context, arg UpdateSeatAvailabilityParams) error {
	_, err := q.db.Exec(ctx, updateSeatAvailability, arg.TicketID, arg.IsAvailable)
	return err
}
