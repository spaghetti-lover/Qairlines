// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: bookings.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBooking = `-- name: CreateBooking :one
  -- user_email VARCHAR(255) REFERENCES Users(email) ON DELETE SET NULL,
  -- trip_type trip_type NOT NULL,
  -- departure_flight_id VARCHAR(20) REFERENCES Flights(flight_id),
  -- return_flight_id VARCHAR(20) REFERENCES Flights(flight_id),
  -- status booking_status NOT NULL DEFAULT 'pending',
  -- created_at timestamptz NOT NULL DEFAULT (now()),
  -- updated_at timestamptz NOT NULL DEFAULT (now())

INSERT INTO bookings (
  booking_id,
  user_email,
  trip_type,
  departure_flight_id,
  return_flight_id,
  status
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING booking_id, user_email, trip_type, departure_flight_id, return_flight_id, status, created_at, updated_at
`

type CreateBookingParams struct {
	BookingID         int64         `json:"booking_id"`
	UserEmail         pgtype.Text   `json:"user_email"`
	TripType          TripType      `json:"trip_type"`
	DepartureFlightID pgtype.Int8   `json:"departure_flight_id"`
	ReturnFlightID    pgtype.Int8   `json:"return_flight_id"`
	Status            BookingStatus `json:"status"`
}

// booking_id VARCHAR(30) PRIMARY KEY,
func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.BookingID,
		arg.UserEmail,
		arg.TripType,
		arg.DepartureFlightID,
		arg.ReturnFlightID,
		arg.Status,
	)
	var i Booking
	err := row.Scan(
		&i.BookingID,
		&i.UserEmail,
		&i.TripType,
		&i.DepartureFlightID,
		&i.ReturnFlightID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBookings = `-- name: DeleteBookings :exec
DELETE FROM bookings
WHERE booking_id = $1
`

func (q *Queries) DeleteBookings(ctx context.Context, bookingID int64) error {
	_, err := q.db.Exec(ctx, deleteBookings, bookingID)
	return err
}

const getBooking = `-- name: GetBooking :one
SELECT booking_id, user_email, trip_type, departure_flight_id, return_flight_id, status, created_at, updated_at FROM bookings
WHERE booking_id = $1 LIMIT 1
`

func (q *Queries) GetBooking(ctx context.Context, bookingID int64) (Booking, error) {
	row := q.db.QueryRow(ctx, getBooking, bookingID)
	var i Booking
	err := row.Scan(
		&i.BookingID,
		&i.UserEmail,
		&i.TripType,
		&i.DepartureFlightID,
		&i.ReturnFlightID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookingHistoryByUID = `-- name: GetBookingHistoryByUID :many
SELECT booking_id
FROM Bookings
JOIN Users u ON Bookings.user_email = u.email
WHERE u.user_id = $1
`

func (q *Queries) GetBookingHistoryByUID(ctx context.Context, userID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getBookingHistoryByUID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var booking_id int64
		if err := rows.Scan(&booking_id); err != nil {
			return nil, err
		}
		items = append(items, booking_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookings = `-- name: ListBookings :many
SELECT booking_id, user_email, trip_type, departure_flight_id, return_flight_id, status, created_at, updated_at FROM bookings
ORDER BY booking_id
LIMIT $1
OFFSET $2
`

type ListBookingsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBookings(ctx context.Context, arg ListBookingsParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Booking{}
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.BookingID,
			&i.UserEmail,
			&i.TripType,
			&i.DepartureFlightID,
			&i.ReturnFlightID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromBookings = `-- name: RemoveUserFromBookings :exec
UPDATE bookings
SET user_email = NULL,
    updated_at = NOW()
WHERE user_email = $1
`

func (q *Queries) RemoveUserFromBookings(ctx context.Context, userEmail pgtype.Text) error {
	_, err := q.db.Exec(ctx, removeUserFromBookings, userEmail)
	return err
}
